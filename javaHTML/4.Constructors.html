<div class="tree-container">
    <details>
    <summary><strong>Java Constructors</strong></summary>
    <p>In Java:</p>
    <ul>
        <li>You can create multiple constructors in a single class without limit.</li>
        <li>Constructors are special methods used to initialize objects.</li>
        <li>They are invoked when an object is created using the <code>new</code> keyword.</li>
    </ul>

    <details>
        <summary><strong>üìö Common Java Terms</strong></summary>
        <table>
            <tr><th>Term</th><th>Explanation</th></tr>
            <tr><td><code>import java.io.*;</code></td><td>Import all classes from <code>java.io</code> package</td></tr>
            <tr><td><code>class</code></td><td>Defines a class containing data and methods</td></tr>
            <tr><td><code>static void main()</code></td><td><code>static</code> means method can be called without object instantiation</td></tr>
            <tr><td><code>void</code></td><td>Method returns no value</td></tr>
            <tr><td><code>System.in</code></td><td>Standard input stream (keyboard input)</td></tr>
            <tr><td><code>System.out</code></td><td>Standard output stream (console output)</td></tr>
            <tr><td><code>println()</code></td><td>Prints text and moves to a new line</td></tr>
        </table>
    </details>

    <details>
        <summary><strong>1. Default Constructor</strong></summary>
        <ul>
            <li>No parameters.</li>
            <li>Provided automatically by Java if no constructor is explicitly defined.</li>
        </ul>
        <pre><code>public class MyClass {
    // Default constructor
    public MyClass() {
        // Initialization logic
    }
}
  </code></pre>
    </details>

    <details>
        <summary><strong>2. Parameterized Constructor</strong></summary>
        <ul>
            <li>Takes one or more parameters.</li>
            <li>Used to initialize object properties with given values.</li>
        </ul>
        <pre><code>public class MyClass {
    public MyClass(int x, String str) {
        // Initialization using parameters
    }
}
  </code></pre>
    </details>

    <details>
        <summary><strong>3. Copy Constructor</strong></summary>
        <ul>
            <li>Creates a new object by copying an existing object's state.</li>
        </ul>
        <pre><code>public class MyClass {
    private int x;
    private String str;

    // Copy constructor
    public MyClass(MyClass original) {
        this.x = original.x;
        this.str = original.str;
    }
}
  </code></pre>
    </details>

    <details>
        <summary><strong>4. Constructor Chaining</strong></summary>
        <ul>
            <li>One constructor calls another within the same class using <code>this()</code>.</li>
        </ul>
        <pre><code>public class MyClass {
    private int x;
    private String str;

    public MyClass(int x, String str) {
        this.x = x;
        this.str = str;
    }

    public MyClass() {
        this(0, "default");
    }
}
</code></pre>
    </details>

    <details>
        <summary><strong>5. Private Constructor</strong></summary>
        <ul>
            <li>Has private access modifier.</li>
            <li>Prevents instantiation from outside the class.</li>
            <li>Commonly used for utility classes or singleton patterns.</li>
        </ul>
        <pre><code>public class UtilityClass {
    private UtilityClass() {
        // Prevent instantiation
    }
}
</code></pre>
    </details>

    <details>
        <summary><strong>Private Class vs Private Constructor</strong></summary>
        <table>
            <tr><th>Feature</th><th>Private Class</th><th>Private Constructor</th></tr>
            <tr><td><strong>Scope</strong></td><td>Accessible only within the enclosing class</td><td>Accessible only within the class itself</td></tr>
            <tr><td><strong>Purpose</strong></td><td>Encapsulate helper functionality, inner logic</td><td>Prevent external instantiation of the class</td></tr>
            <tr><td><strong>Instantiation</strong></td><td>Can be instantiated inside the enclosing class</td><td>Prevents instantiation except from within the class</td></tr>
            <tr><td><strong>Use Cases</strong></td><td>Nested helper classes</td><td>Singleton pattern, utility classes, controlled creation</td></tr>
        </table>
    </details>

    <details>
        <summary><strong>Example: Private Class</strong></summary>
        <pre><code>public class OuterClass {

    private static class InnerClass {
        // Inner logic
    }

    public void doSomething() {
        InnerClass inner = new InnerClass();
        // Use inner instance
    }
}
</code></pre>
    </details>

    <details>
        <summary><strong>Example: Private Constructor (Singleton)</strong></summary>
        <pre><code>public class Singleton {

    private static Singleton instance;

    private Singleton() {
        // Private constructor
    }

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

public class Main {
    public static void main(String[] args) {
        // Access the Singleton instance
        Singleton singleObject = Singleton.getInstance();

        // Use its methods
        singleObject.showMessage();
    }
}
</code></pre>
    </details>

    <details>
        <summary><strong>Summary</strong></summary>
        <ul>
            <li><strong>Private Class:</strong> Controls access to the class itself (typically nested classes).</li>
            <li><strong>Private Constructor:</strong> Controls instantiation of the class.</li>
            <li>You don‚Äôt use <code>new Singleton()</code> because the constructor is private.</li>
            <li>You always call <code>Singleton.getInstance()</code> to get the single shared instance.</li>
            <li>Every time you call <code>getInstance()</code>, it will return the same object.</li>
        </ul>
    </details>
    <hr>
    <details>
        <summary><strong>üß© 1Ô∏è‚É£ Constructor Chaining</strong></summary>
        You already know this one ‚Äî when one constructor calls another within the same class using <code>this()</code> or a parent‚Äôs constructor (<code>super()</code>).
        <pre><code>class Vehicle {
    Vehicle() { System.out.println("Vehicle"); }
    Vehicle(String type) { this(); System.out.println(type); }
}
</code></pre>
        <p>‚úÖ <strong>Purpose:</strong> Avoid code duplication and ensure consistent initialization.</p>
    </details>

    <hr>
    <details>
        <summary><strong>üß± 2Ô∏è‚É£ Method Chaining (Fluent Interface)</strong></summary>
        This is very common in modern Java APIs ‚Äî a style where methods return <code>this</code> so calls can be chained.
        <br><br>
        <strong>üîπ Basic Example</strong>
        <pre><code>class Person {
    private String name;
    private int age;

    public Person setName(String name) {
        this.name = name;
        return this;
    }

    public Person setAge(int age) {
        this.age = age;
        return this;
    }
}

Person p = new Person()
                .setName("Alice")
                .setAge(30);
</code></pre>
        <p>‚úÖ Each setter returns the same object ‚Üí allows continuous chaining.</p>
        <p>This is called the <strong>Fluent Interface Pattern</strong>.</p>

        <br>
        <strong>üîπ Real-world Example: <code>StringBuilder</code></strong>
        <pre><code>String result = new StringBuilder()
                    .append("Hello ")
                    .append("World")
                    .append("!")
                    .toString();
</code></pre>
        <p>Each <code>.append()</code> returns the same <code>StringBuilder</code> instance ‚Äî that‚Äôs <strong>method chaining</strong> in action.</p>

        <br>
        <strong>üîπ Another Example: Streams API</strong>
        <pre><code>List&lt;Integer&gt; result = numbers.stream()
                              .filter(n -&gt; n % 2 == 0)
                              .map(n -&gt; n * 2)
                              .sorted()
                              .toList();
</code></pre>
        <p>Here, every intermediate operation returns a new <code>Stream</code>, enabling chainable operations.</p>
    </details>

    <hr>
    <details>
        <summary><strong>üß© 3Ô∏è‚É£ Builder Pattern (Chaining for Object Construction)</strong></summary>
        Builder pattern is an <strong>advanced form of method chaining</strong> for immutable or complex objects.
        <br><br>
        <strong>Example:</strong>
        <pre><code>class User {
    private final String name;
    private final int age;

    private User(Builder builder) {
        this.name = builder.name;
        this.age = builder.age;
    }

    public static class Builder {
        private String name;
        private int age;

        public Builder name(String name) {
            this.name = name;
            return this;
        }

        public Builder age(int age) {
            this.age = age;
            return this;
        }

        public User build() {
            return new User(this);
        }
    }
}
</code></pre>
        <strong>Usage:</strong>
        <pre><code>User u = new User.Builder()
                .name("Alice")
                .age(25)
                .build();
</code></pre>
        <p>‚úÖ <strong>Why it‚Äôs popular:</strong></p>
        <ul>
            <li>Makes object construction readable</li>
            <li>Works well for immutable objects</li>
            <li>Avoids telescoping constructors</li>
        </ul>
    </details>

    <hr>
    <details>
        <summary><strong>‚öôÔ∏è 4Ô∏è‚É£ Stream Chaining / Functional Chaining</strong></summary>
        In <strong>functional programming style</strong>, chaining is about <strong>composing transformations</strong>.
        <br><br>
        <strong>Example:</strong>
        <pre><code>String result = Optional.of(" Java ")
                        .map(String::trim)
                        .map(String::toUpperCase)
                        .orElse("EMPTY");
</code></pre>
        <p>Each call returns another <code>Optional</code> ‚Üí pure functional chaining.</p>
    </details>

    <hr>
    <details>
        <summary><strong>üß† 5Ô∏è‚É£ Operator / DSL-style Chaining</strong></summary>
        Some frameworks design <strong>DSLs (Domain-Specific Languages)</strong> using chaining to read like English.
        <br><br>
        <strong>Example (Spring Security or Mockito):</strong>
        <pre><code>http.authorizeRequests()
    .antMatchers("/admin").hasRole("ADMIN")
    .antMatchers("/user").authenticated()
    .and()
    .formLogin();
</code></pre>
        or
        <pre><code>verify(userService, times(1)).save(any());
</code></pre>
        <p>‚úÖ This chaining builds configuration objects step-by-step, making APIs more expressive.</p>
    </details>

    <hr>
    <details>
        <summary><strong>‚ö° 6Ô∏è‚É£ Other Types of ‚ÄúChaining‚Äù Concepts</strong></summary>
        <table>
            <thead>
            <tr>
                <th>Type</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><strong>Exception chaining</strong></td>
                <td>One exception wraps another (cause chaining)</td>
                <td><code>new RuntimeException("msg", cause)</code></td>
            </tr>
            <tr>
                <td><strong>Stream/Functional chaining</strong></td>
                <td>Each method returns a new instance for next transformation</td>
                <td><code>.filter().map().collect()</code></td>
            </tr>
            <tr>
                <td><strong>Builder chaining</strong></td>
                <td>Build complex objects fluently</td>
                <td><code>.name().age().build()</code></td>
            </tr>
            <tr>
                <td><strong>Pipeline chaining</strong></td>
                <td>Sequence of processing steps in design (e.g., servlet filters)</td>
                <td><code>doFilter(request, response)</code></td>
            </tr>
            </tbody>
        </table>
    </details>
        <hr>
        <details>
            <summary><strong>‚ö†Ô∏è 7Ô∏è‚É£ Pitfalls / Best Practices</strong></summary>
            <ul>
                <li>Return <code>this</code> <strong>only when mutating the same instance</strong> (Builder pattern creates a new instance at the end).</li>
                <li>Avoid chaining <strong>void</strong> methods ‚Äî they break the chain.</li>
                <li>Ensure methods in the chain <strong>don‚Äôt depend on execution order unexpectedly</strong>.</li>
                <li>Use chaining for <strong>readability</strong>, not just compactness.</li>
            </ul>
        </details>

        <hr>
        <details>
            <summary><strong>‚úÖ Summary</strong></summary>
            <table>
                <thead>
                <tr>
                    <th>Type</th>
                    <th>Example</th>
                    <th>Purpose</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td><strong>Constructor chaining</strong></td>
                    <td><code>this()</code> / <code>super()</code></td>
                    <td>Reuse constructor logic</td>
                </tr>
                <tr>
                    <td><strong>Method chaining</strong></td>
                    <td><code>.setName().setAge()</code></td>
                    <td>Fluent interface / readability</td>
                </tr>
                <tr>
                    <td><strong>Builder chaining</strong></td>
                    <td><code>.name().age().build()</code></td>
                    <td>Complex immutable object creation</td>
                </tr>
                <tr>
                    <td><strong>Stream chaining</strong></td>
                    <td><code>.filter().map().collect()</code></td>
                    <td>Functional data transformation</td>
                </tr>
                <tr>
                    <td><strong>Exception chaining</strong></td>
                    <td><code>new RuntimeException(cause)</code></td>
                    <td>Error context propagation</td>
                </tr>
                </tbody>
            </table>

            <br>
            <strong>üîë TL;DR</strong>
            <blockquote>
                ‚úÖ <em>Constructor chaining</em> ‚Üí within the same class.<br>
                ‚úÖ <em>Method chaining</em> ‚Üí between method calls returning <code>this</code> or new objects.<br>
                ‚úÖ <em>Builder / Stream chaining</em> ‚Üí modern fluent APIs and functional pipelines.
            </blockquote>
        </details>

    </details>

</div>
