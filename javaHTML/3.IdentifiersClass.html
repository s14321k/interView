<!--<meta charset="UTF-8">-->
<!--<meta name="viewport" content="width=device-width, initial-scale=1.0">-->
<!--<title>Java Principles, Best Practices & Memory Management</title>-->
<!--&lt;!&ndash; Step 1 & 2: Link to the external stylesheet from the embedded document &ndash;&gt;-->
<!--&lt;!&ndash; The path is relative to this file (javaHTML/1.JavaPrinciplesBestPractices&MemoryManagement.html) &ndash;&gt;-->
<!--<link rel="stylesheet" type="text/css" href="../css/style.css">-->

<!--<script src="js/scripts.js"></script>-->

<div class="tree-container">
    <h1>üÜî Identifiers, Class in Java</h1>

    <details>
        <summary><strong>Java Identifiers and Keywords</strong></summary>

        <ul>
            <li>Identifiers start with alphabets, underscore <code>_</code>, or dollar <code>$</code>.</li>
            <li>Case sensitive.</li>
            <li><strong>Keywords cannot be used as identifiers.</strong></li>
        </ul>

        <h3>Some Java Keywords</h3>
        <table>
            <tr><th>Keyword</th><th>Usage</th></tr>
            <tr><td><code>class</code></td><td>Declare a class</td></tr>
            <tr><td><code>public</code></td><td>Accessibility modifier</td></tr>
            <tr><td><code>static</code></td><td>Belongs to class rather than instance</td></tr>
            <tr><td><code>void</code></td><td>Method returns nothing</td></tr>
            <tr><td><code>main</code></td><td>Entry point of Java program</td></tr>
            <tr><td><code>new</code></td><td>Create new object</td></tr>
            <tr><td><code>if</code>, <code>else</code></td><td>Conditional statements</td></tr>
            <tr><td><code>for</code>, <code>while</code>, <code>do</code></td><td>Loop constructs</td></tr>
            <tr><td><code>return</code></td><td>Exit method and optionally return value</td></tr>
            <tr><td><code>try</code>, <code>catch</code>, <code>finally</code></td><td>Exception handling blocks</td></tr>
            <tr><td><code>throw</code>, <code>throws</code></td><td>Exception declaration and throwing</td></tr>
        </table>

        <h3>Java Identifiers (Short &amp; Simple)</h3>
        <p><strong>Identifiers</strong> are names for variables, methods, classes, etc.</p>

        <p><strong>Rules:</strong></p>
        <ul>
            <li>Must start with a letter (A‚ÄìZ, a‚Äìz), underscore <code>_</code>, or dollar sign <code>$</code>.</li>
            <li>Can contain digits (0‚Äì9) after the first character.</li>
            <li>Case sensitive (<code>MyVar</code> ‚â† <code>myvar</code>).</li>
            <li>Cannot use Java keywords (like <code>class</code>, <code>int</code>).</li>
        </ul>

        <p><strong>Examples:</strong></p>
        <pre><code>int age;
String _name;
double $salary;
// int 2ndValue; // Invalid: cannot start with digit
// int class;    // Invalid: 'class' is a keyword
  </code></pre>

        <p><strong>Common Java Keywords:</strong><br>
            <code>class</code>, <code>public</code>, <code>static</code>, <code>void</code>,
            <code>if</code>, <code>else</code>, <code>for</code>, <code>while</code>,
            <code>return</code>, <code>try</code>, <code>catch</code>, <code>throw</code>, <code>throws</code>
        </p>

        <details>
            <summary><strong>Variables in Java</strong></summary>

            <ul>
                <li><strong>Local:</strong> Inside method body; cannot be <code>static</code>.</li>
                <li><strong>Instance:</strong> Inside class body; each object has its own copy.</li>
                <li><strong>Static:</strong> Shared across all instances; memory allocated once when class loads.</li>
            </ul>
        </details>

        <hr>


        <h2>Modifiers in Java</h2>
        <hr>

        <h2>1. Access Modifiers</h2>

        <table>
            <thead>
            <tr>
                <th>Modifier</th>
                <th>Access within class</th>
                <th>Access within package</th>
                <th>Access outside package by subclass</th>
                <th>Access outside package (non-subclass)</th>
            </tr>
            </thead>
            <tbody>
            <tr><td><strong>public</strong></td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
            <tr><td><strong>protected</strong></td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr>
            <tr><td><strong>default</strong></td><td>Yes</td><td>Yes</td><td>No</td><td>No</td></tr>
            <tr><td><strong>private</strong></td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr>
            </tbody>
        </table>

        <h3>Details</h3>
        <ul>
            <li><code>public</code>: Accessible from anywhere.</li>
            <li><code>protected</code>: Accessible in the same package and subclasses (even outside package).</li>
            <li><code>default</code> (no modifier): Accessible only within the same package.</li>
            <li><code>private</code>: Accessible only within the defining class.</li>
        </ul>

        <h3>Example of Private Modifier</h3>
        <pre><code class="language-java">class Sarath {
    private String name = "sarath"; // accessible only within this class
}

class Friend {
    public void access() {
        Sarath sar = new Sarath();
        String var = sar.name; // Compilation error: name has private access in Sarath
    }
}
</code></pre>

        <hr>

        <h3>Private Constructor</h3>
        <ul>
            <li>A constructor declared <code>private</code> restricts instantiation <strong>outside the class</strong>.</li>
            <li>Commonly used in:
                <ul>
                    <li><strong>Singleton Pattern</strong> (single instance control)</li>
                    <li><strong>Utility classes</strong> (only static members, no instances)</li>
                </ul>
            </li>
        </ul>

        <pre><code class="language-java">public class UtilityClass {
    private UtilityClass() {
        // Prevent instantiation
    }
}
</code></pre>

        <hr>

        <h2>2. Non-Access Modifiers</h2>

        <table>
            <thead>
            <tr>
                <th>Modifier</th>
                <th>Applies To</th>
                <th>Purpose</th>
            </tr>
            </thead>
            <tbody>
            <tr><td><code>static</code></td><td>Variables, methods, inner classes</td><td>Makes members belong to the class rather than instances</td></tr>
            <tr><td><code>final</code></td><td>Variables, methods, classes</td><td>Prevents reassignment, method overriding, or subclassing</td></tr>
            <tr><td><code>abstract</code></td><td>Classes, methods</td><td>Defines classes or methods that cannot be instantiated or must be overridden</td></tr>
            <tr><td><code>native</code></td><td>Methods</td><td>Declares a method implemented in platform-dependent code (e.g., C/C++)</td></tr>
            <tr><td><code>strictfp</code></td><td>Classes, methods</td><td>Ensures consistent floating-point calculations across platforms (Removed in Java 17)</td></tr>
            </tbody>
        </table>

        <hr>

        <h3><code>static</code> Modifier</h3>

        <ul>
            <li><strong>Static Variables (Class Variables)</strong>
                <ul>
                    <li>Single copy shared across all instances.</li>
                    <li>Used for constants or shared data.</li>
                </ul>
            </li>
        </ul>

        <pre><code class="language-java">public class MyClass {
    static int staticCount = 0;
}
</code></pre>

        <ul>
            <li><strong>Static Methods</strong>
                <ul>
                    <li>Called without creating an instance.</li>
                    <li>Cannot access instance members directly.</li>
                </ul>
            </li>
        </ul>

        <pre><code class="language-java">public class MyClass {
    static void display() {
        System.out.println("Static method");
    }
}
</code></pre>

        <ul>
            <li><strong>Static Blocks</strong>
                <ul>
                    <li>Run once when the class is loaded.</li>
                    <li>Used for static variable initialization or setup.</li>
                </ul>
            </li>
        </ul>

        <pre><code class="language-java">public class MyClass {
    static {
        System.out.println("Static block executed");
    }
}
</code></pre>

        <p>In Java, a <strong>static block</strong> (also called a <em>static initializer block</em>) is used to initialize static variables or run some setup code when the class is first loaded into memory by the JVM.</p>

        <hr>

        <h3>‚úÖ Key Points about Static Blocks:</h3>
        <ol>
            <li><strong>Executed Once</strong> ‚Äî Runs only once, when the class is loaded into the JVM (before <code>main()</code> runs and before any object is created).</li>
            <li><strong>Initialization of Static Variables</strong> ‚Äî Useful for assigning complex values to <code>static</code> variables that cannot be set with a single statement.</li>
            <li><strong>Runs Before Constructor</strong> ‚Äî Executes before any constructor or instance block runs.</li>
            <li><strong>Multiple Static Blocks</strong> ‚Äî You can have more than one static block; they are executed in the order they appear in the class.</li>
        </ol>

        <hr>

        <h3>üìå Example:</h3>
        <pre><code class="language-java">class Demo {
    static int value;

    // Static block
    static {
        System.out.println("Static block executed.");
        value = 42; // Initializing static variable
    }

    public static void main(String[] args) {
        System.out.println("Main method executed.");
        System.out.println("Value = " + value);
    }
}
</code></pre>

        <p><strong>Output:</strong></p>
        <pre><code>Static block executed.
Main method executed.
Value = 42
</code></pre>

        <hr>

        <h3>‚ö° Common Uses:</h3>

        <ol>
            <li><strong>Complex static variable initialization</strong>
                <pre><code class="language-java">static Map&lt;Integer, String&gt; map;
static {
    map = new HashMap&lt;&gt;();
    map.put(1, "One");
    map.put(2, "Two");
}
</code></pre></li>

            <li><strong>Loading native libraries</strong>
                <pre><code class="language-java">static {
    System.loadLibrary("nativeLib");
}
</code></pre></li>

            <li><strong>Configuration setup</strong> (e.g., reading from a file or environment variables at class load time).</li>
        </ol>

        <h3><code>final</code> Modifier</h3>

        <ul>
            <li><strong>Final Variables</strong>
                <ul>
                    <li>Constants; value assigned once and cannot be changed.</li>
                </ul>
            </li>
        </ul>

        <pre><code class="language-java">final int MAX_USERS = 100;
</code></pre>

        <ul>
            <li><strong>Final Methods</strong>
                <ul>
                    <li>Cannot be overridden by subclasses.</li>
                </ul>
            </li>
        </ul>

        <pre><code class="language-java">public final void display() {
    System.out.println("Cannot override this method");
}
</code></pre>

        <ul>
            <li><strong>Final Classes</strong>
                <ul>
                    <li>Cannot be subclassed.</li>
                </ul>
            </li>
        </ul>

        <pre><code class="language-java">public final class UtilityClass {
    // cannot be extended
}
</code></pre>

        <hr>

        <h3><code>abstract</code> Modifier</h3>

        <ul>
            <li><strong>Abstract Classes</strong>
                <ul>
                    <li>Cannot be instantiated directly.</li>
                    <li>May contain abstract methods (no implementation).</li>
                </ul>
            </li>
        </ul>

        <pre><code class="language-java">public abstract class Shape {
    abstract void draw();
}
</code></pre>

        <ul>
            <li><strong>Abstract Methods</strong>
                <ul>
                    <li>Must be overridden by subclasses.</li>
                </ul>
            </li>
        </ul>

        <pre><code class="language-java">public abstract void draw();
</code></pre>

        <hr>

        <h3><code>native</code> Modifier</h3>

        <ul>
            <li>Indicates that the method is implemented in platform-dependent code, typically in C or C++.</li>
        </ul>

        <pre><code class="language-java">public native void nativeMethod();
</code></pre>

        <ul>
            <li>Requires use of JNI (Java Native Interface).</li>
        </ul>

        <hr>

        <h4>Summary Table</h4>

        <table>
            <thead>
            <tr>
                <th>Modifier</th>
                <th>Type</th>
                <th>Can apply to</th>
                <th>Effect / Use case</th>
            </tr>
            </thead>
            <tbody>
            <tr><td><code>public</code></td><td>Access</td><td>Classes, methods, vars</td><td>Accessible everywhere</td></tr>
            <tr><td><code>protected</code></td><td>Access</td><td>Methods, vars</td><td>Package + subclasses only</td></tr>
            <tr><td><code>default</code></td><td>Access</td><td>Classes, methods, vars</td><td>Package only</td></tr>
            <tr><td><code>private</code></td><td>Access</td><td>Classes, methods, vars</td><td>Class only</td></tr>
            <tr><td><code>static</code></td><td>Non-access</td><td>Vars, methods, classes</td><td>Belongs to class, shared</td></tr>
            <tr><td><code>final</code></td><td>Non-access</td><td>Vars, methods, classes</td><td>Constant, no override, no subclass</td></tr>
            <tr><td><code>abstract</code></td><td>Non-access</td><td>Classes, methods</td><td>Abstract behavior, must subclass/override</td></tr>
            <tr><td><code>native</code></td><td>Non-access</td><td>Methods</td><td>Implemented in native code</td></tr>
            <tr><td><code>strictfp</code></td><td>Non-access</td><td>Classes, methods</td><td>Consistent floating-point (removed in Java 17)</td></tr>
            </tbody>
        </table>

        <hr>

    </details>

    <details>
        <h2>üè∑Ô∏è What is a Class?</h2>
        <p>A <strong>class</strong> is a blueprint or template from which objects are created. It contains data (fields) and behaviors (methods).</p>

        <hr>

        <summary><strong>Common Java Class Types</strong></summary>

        <h3>1. Regular (Concrete) Class</h3>
        <p>Can be instantiated to create objects. Contains fields, methods, constructors.</p>
        <pre><code>public class Car {
    // Fields, methods, constructors
}
  </code></pre>

        <h3>2. Abstract Class</h3>
        <ul>
            <li>Cannot be instantiated.</li>
            <li>May contain abstract methods to be implemented by subclasses.</li>
        </ul>
        <pre><code>public abstract class Shape {
    // Abstract and regular methods
}
  </code></pre>

        <h3>3. Interface</h3>
        <ul>
            <li>Collection of abstract methods (before Java 8).</li>
            <li>From Java 8, can have default method implementations.</li>
        </ul>
        <pre><code>public interface Drawable {
    void draw(); // implicitly public and abstract
}
  </code></pre>

        <h3>4. Final Class</h3>
        <p>Cannot be extended (subclassed).</p>
        <pre><code>public final class UtilityClass {
    // Methods and fields
}
  </code></pre>

        <h3>5. Inner Class</h3>
        <ul>
            <li>Defined inside another class.</li>
            <li>Can be static or non-static.</li>
        </ul>
        <pre><code>public class Outer {
    class Inner {
        // Inner class
    }
}
  </code></pre>

        <h3>6. Static Nested Class</h3>
        <ul>
            <li>Static class inside another class.</li>
            <li>Cannot access instance variables of outer class.</li>
        </ul>
        <pre><code>public class Outer {
    static class Nested {
        // Static nested class
    }
}
  </code></pre>

        <h3>7. Anonymous Class</h3>
        <ul>
            <li>Local class without a name.</li>
            <li>Usually used to instantiate interfaces or extend classes once.</li>
        </ul>
        <pre><code>Runnable myRunnable = new Runnable() {
    public void run() {
        // Implementation
    }
};
  </code></pre>

        <h2>üß© Example of Anonymous Class</h2>
        <pre><code>class Polygon {
    public void display() {
        System.out.println("Inside the Polygon class");
    }
}

class AnonymousDemo {
    public void createClass() {
        // Anonymous class extending Polygon
        Polygon p1 = new Polygon() {
            public void display() {
                System.out.println("Inside an anonymous class.");
            }
        };
        p1.display();
    }
}

class Main {
    public static void main(String[] args) {
        AnonymousDemo an = new AnonymousDemo();
        an.createClass();
    }
}
</code></pre>

        <p><strong>Output:</strong><br>
            <code>Inside an anonymous class.</code></p>
    </details>
</div>