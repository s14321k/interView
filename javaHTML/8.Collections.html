<h1 id="java-collections">Java Collections</h1>

<div id="collections-div" class="tree-container">

<details>
    <summary><h2>üß± Java Collections Framework Guide</h2></summary>

    <h3>üîç Why Collections Framework?</h3>
    <ul>
        <li>Avoids writing boilerplate data structure logic (list, set, map, queue).</li>
        <li>Offers ready-to-use implementations and utility methods.</li>
        <li>Ensures standardization across all Java applications.</li>
    </ul>

    <hr>

    <img src="images/JavaBasic/ListQueueSet.png" alt="Collection Hierarchy"/>

    <hr>

    <h3>üåê Collections Hierarchy Overview</h3>

    <pre class="mermaid">
        flowchart TD

        %% Iterable hierarchy
        Iterable["Iterable"]
        Iterable --> Collection["Collection"]

        Collection --> List["List"]
        List --> ArrayList["ArrayList"]
        List --> LinkedList["LinkedList"]
        List --> Vector["Vector"]
        Vector --> Stack["Stack"]

        Collection --> Set["Set"]
        Set --> HashSet["HashSet"]
        Set --> LinkedHashSet["LinkedHashSet"]
        Set --> TreeSet["TreeSet"]

        Collection --> Queue["Queue"]
        Queue --> PriorityQueue["PriorityQueue"]
        Queue --> Deque["Deque"]
        Deque --> ArrayDeque["ArrayDeque"]

        %% Map hierarchy
        Map["Map (Not part of Collection)"]
        Map --> HashMap["HashMap"]
        HashMap --> LinkedHashMap["LinkedHashMap"]
        Map --> TreeMap["TreeMap"]
    </pre>

    <hr>

    <h3>üß≠ Interactive Decision Flowchart: Pick the Right Collection</h3>

    <pre class="mermaid">
        flowchart TD

        Start(["Start"])
        Start --> NeedKeyValue{"Do you need key-value pairs?"}

        %% Map branch
        NeedKeyValue -- Yes --> UseMap["Use a Map"]
        UseMap --> KeysSorted{"Do keys need to be sorted?"}
        KeysSorted -- Yes --> TreeMap["TreeMap"]
        KeysSorted -- No --> PreserveOrderMap{"Preserve insertion order?"}
        PreserveOrderMap -- Yes --> LinkedHashMap["LinkedHashMap"]
        PreserveOrderMap -- No --> HashMap["HashMap"]

        %% Collection branch
        NeedKeyValue -- No --> CollectionSide["Move to Collection (List or Set)"]
        CollectionSide --> AllowDuplicates{"Allow duplicates?"}

        %% List branch
        AllowDuplicates -- Yes --> UseList["Use a List"]
        UseList --> RandomAccess{"Need random access by index?"}
        RandomAccess -- Yes --> ArrayList["ArrayList"]
        RandomAccess -- No --> LinkedList["LinkedList"]

        %% Set branch
        AllowDuplicates -- No --> UseSet["Use a Set"]
        UseSet --> SortedSet{"Need elements sorted?"}
        SortedSet -- Yes --> TreeSet["TreeSet"]
        SortedSet -- No --> PreserveOrderSet{"Preserve insertion order?"}
        PreserveOrderSet -- Yes --> LinkedHashSet["LinkedHashSet"]
        PreserveOrderSet -- No --> HashSet["HashSet"]

        %% Thread-safety check
        AfterSelection["After selecting collection"] --> ThreadSafe{"Need thread safety?"}
        ThreadSafe -- Yes --> ConcurrentOptions["Use concurrent/synchronized alternatives:<br/>- ConcurrentHashMap<br/>- CopyOnWriteArrayList<br/>- Collections.synchronizedSet(...)"]
        ThreadSafe -- No --> UseDefault["Use as-is (default)"]

        %% Connections
        TreeMap --> AfterSelection
        LinkedHashMap --> AfterSelection
        HashMap --> AfterSelection
        ArrayList --> AfterSelection
        LinkedList --> AfterSelection
        TreeSet --> AfterSelection
        LinkedHashSet --> AfterSelection
        HashSet --> AfterSelection
    </pre>

    <summary><h4>üß∞ Summary Table</h4></summary>

    <table>
        <thead>
        <tr>
            <th>Need</th>
            <th>Collection</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>Key-value with sorted keys</td>
            <td><code>TreeMap</code></td>
        </tr>
        <tr>
            <td>Key-value with insertion order</td>
            <td><code>LinkedHashMap</code></td>
        </tr>
        <tr>
            <td>Simple key-value (no order)</td>
            <td><code>HashMap</code></td>
        </tr>
        <tr>
            <td>List with index access</td>
            <td><code>ArrayList</code></td>
        </tr>
        <tr>
            <td>List without index priority</td>
            <td><code>LinkedList</code></td>
        </tr>
        <tr>
            <td>Unique, sorted elements</td>
            <td><code>TreeSet</code></td>
        </tr>
        <tr>
            <td>Unique, insertion order</td>
            <td><code>LinkedHashSet</code></td>
        </tr>
        <tr>
            <td>Unique, no order</td>
            <td><code>HashSet</code></td>
        </tr>
        <tr>
            <td>Thread safety</td>
            <td><code>ConcurrentHashMap</code>, <code>CopyOnWriteArrayList</code>, <code>synchronizedMap</code>, etc.</td>
        </tr>
        </tbody>
    </table>

    <details>
        <summary><h2>üõ† Core Interfaces and Key Differences</h2></summary>

        <h3>Iterable vs Collection</h3>
        <table>
            <thead>
            <tr>
                <th>Interface</th>
                <th>Role</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><code>Iterable</code></td>
                <td>Root interface for iteration</td>
            </tr>
            <tr>
                <td><code>Collection</code></td>
                <td>Base interface for Lists, Sets, Queues</td>
            </tr>
            </tbody>
        </table>

        <h3>Iterator vs Enumeration</h3>
        <table>
            <thead>
            <tr>
                <th>Feature</th>
                <th>Iterator</th>
                <th>Enumeration</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Remove Element</td>
                <td>‚úÖ Allows <code>remove()</code> during traversal</td>
                <td>‚ùå Read-only; cannot modify</td>
            </tr>
            <tr>
                <td>Coverage</td>
                <td>Universal cursor (works with all collections)</td>
                <td>Only for legacy classes like <code>Vector</code>, <code>Hashtable</code></td>
            </tr>
            <tr>
                <td>Method Support</td>
                <td><code>hasNext()</code>, <code>next()</code>, <code>remove()</code></td>
                <td><code>hasMoreElements()</code>, <code>nextElement()</code></td>
            </tr>
            <tr>
                <td>Direction</td>
                <td>Forward only</td>
                <td>Forward only</td>
            </tr>
            <tr>
                <td>Used For</td>
                <td>All modern collections</td>
                <td>Legacy (<code>Vector</code>, <code>Hashtable</code>)</td>
            </tr>
            <tr>
                <td>Thread Safety</td>
                <td>Not thread-safe by default</td>
                <td>‚ùå Not thread-safe</td>
            </tr>
            <tr>
                <td>Fail-fast</td>
                <td>‚úÖ</td>
                <td>‚ùå</td>
            </tr>
            </tbody>
        </table>

        <details>
            <summary>üì¶ <strong>Utility Classes and Interfaces</strong></summary>

            <h4>Collection Interface Methods</h4>
            <ul>
                <li><code>add(E e)</code>, <code>remove(Object o)</code></li>
                <li><code>addAll()</code>, <code>removeAll()</code></li>
                <li><code>size()</code>, <code>isEmpty()</code></li>
                <li><code>clear()</code></li>
                <li><code>stream()</code></li>
            </ul>

            <h4>Iterator Interface</h4>
            <ul>
                <li><code>hasNext()</code>, <code>next()</code>, <code>remove()</code></li>
            </ul>

            <h4>Iterable Interface</h4>
            <ul>
                <li><code>iterator()</code> ‚Äî only method</li>
            </ul>
        </details>
    </details>
    <details open>
        <summary><h2>üß© List Implementations</h2></summary>

        <details open>
            <summary><strong>üìã List Implementations</strong></summary>

            <table>
                <thead>
                <tr>
                    <th>Type</th>
                    <th>Order Maintained</th>
                    <th>Sorted</th>
                    <th>Allows Duplicates</th>
                    <th>Thread Safe</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>ArrayList</td>
                    <td>‚úÖ Yes</td>
                    <td>‚ùå No</td>
                    <td>‚úÖ Yes</td>
                    <td>‚ùå No</td>
                </tr>
                <tr>
                    <td>LinkedList</td>
                    <td>‚úÖ Yes</td>
                    <td>‚ùå No</td>
                    <td>‚úÖ Yes</td>
                    <td>‚ùå No</td>
                </tr>
                <tr>
                    <td>Vector</td>
                    <td>‚úÖ Yes</td>
                    <td>‚ùå No</td>
                    <td>‚úÖ Yes</td>
                    <td>‚úÖ Yes</td>
                </tr>
                <tr>
                    <td>Stack</td>
                    <td>‚úÖ Yes</td>
                    <td>‚ùå No</td>
                    <td>‚úÖ Yes</td>
                    <td>‚úÖ Yes (inherited from Vector)</td>
                </tr>
                </tbody>
            </table>

            <h3>ArrayList</h3>
            <ul>
                <li>Backed by <strong>resizable array</strong></li>
                <li>Random access supported (O(1))</li>
                <li>Not synchronized</li>
            </ul>

            <h3>LinkedList</h3>
            <ul>
                <li>Doubly linked list</li>
                <li>Insertion/deletion faster (O(1) at ends)</li>
                <li>Slower random access (O(n))</li>
            </ul>

            <img src="images/JavaBasic/ArrayListVsLinkedList.png" alt="ArrayList vs LinkedList" />
            <img src="images/JavaBasic/singlyLinkedList.png" alt="Singly Linked List" />
            <img src="images/JavaBasic/doublyLinkedList.png" alt="Doubly Linked List" />
            <img src="images/JavaBasic/singlyVsDouble1.png" alt="Singly vs Double 1" />
            <img src="images/JavaBasic/singlyVsDouble2.png" alt="Singly vs Double 2" />

            <h3>Vector (Legacy)</h3>
            <ul>
                <li>Synchronized version of ArrayList</li>
                <li>Avoid unless thread-safe list is needed</li>
            </ul>

            <h3>Stack (Legacy)</h3>
            <ul>
                <li>LIFO structure</li>
                <li>Prefer <code>Deque</code> (like <code>ArrayDeque</code>) over <code>Stack</code></li>
            </ul>
        </details>
    </details>

    <hr/>

    <details open>
        <summary><h2>üåÄ Queue Implementations</h2></summary>

        <details open>
            <summary><strong>üîÑ Queue & Deque</strong></summary>

            <table>
                <thead>
                <tr>
                    <th>Interface</th>
                    <th>Implementations</th>
                    <th>Notes</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td><code>Queue</code></td>
                    <td><code>LinkedList</code>, <code>PriorityQueue</code></td>
                    <td>FIFO, priority-based</td>
                </tr>
                <tr>
                    <td><code>Deque</code></td>
                    <td><code>ArrayDeque</code>, <code>LinkedList</code></td>
                    <td>Double-ended (add/remove from both ends)</td>
                </tr>
                <tr>
                    <td><code>BlockingQueue</code></td>
                    <td><code>LinkedBlockingQueue</code>, <code>ArrayBlockingQueue</code></td>
                    <td>Thread-safe queues</td>
                </tr>
                </tbody>
            </table>

            <br/>

            <table>
                <thead>
                <tr>
                    <th>Type</th>
                    <th>Order Maintained</th>
                    <th>Sorted</th>
                    <th>Allows Duplicates</th>
                    <th>Thread Safe</th>
                    <th>Nulls Allowed</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td><strong>Queue (Interface)</strong></td>
                    <td>‚úÖ FIFO</td>
                    <td>‚ùå No</td>
                    <td>‚úÖ Yes</td>
                    <td>Depends on implementation</td>
                    <td>Depends on implementation</td>
                </tr>
                <tr>
                    <td><strong>Deque (Interface)</strong></td>
                    <td>‚úÖ Ends</td>
                    <td>‚ùå No</td>
                    <td>‚úÖ Yes</td>
                    <td>Depends on implementation</td>
                    <td>Depends on implementation</td>
                </tr>
                <tr>
                    <td><strong>ArrayDeque</strong></td>
                    <td>‚úÖ Yes</td>
                    <td>‚ùå No</td>
                    <td>‚úÖ Yes</td>
                    <td>‚ùå No</td>
                    <td><strong>No nulls</strong></td>
                </tr>
                <tr>
                    <td><strong>LinkedList (as Queue)</strong></td>
                    <td>‚úÖ Yes</td>
                    <td>‚ùå No</td>
                    <td>‚úÖ Yes</td>
                    <td>‚ùå No</td>
                    <td><strong>Multiple nulls</strong></td>
                </tr>
                <tr>
                    <td><strong>PriorityQueue</strong></td>
                    <td>‚úÖ Partial (Heap)</td>
                    <td>‚úÖ Yes</td>
                    <td>‚úÖ Yes</td>
                    <td>‚ùå No</td>
                    <td><strong>No nulls</strong></td>
                </tr>
                <tr>
                    <td><strong>ConcurrentLinkedQueue</strong></td>
                    <td>‚úÖ Yes</td>
                    <td>‚ùå No</td>
                    <td>‚úÖ Yes</td>
                    <td>‚úÖ Yes</td>
                    <td><strong>No nulls</strong></td>
                </tr>
                <tr>
                    <td><strong>BlockingQueue (e.g. LinkedBlockingQueue)</strong></td>
                    <td>‚úÖ Yes</td>
                    <td>‚ùå No</td>
                    <td>‚úÖ Yes</td>
                    <td>‚úÖ Yes</td>
                    <td><strong>No nulls</strong></td>
                </tr>
                </tbody>
            </table>

            <hr/>

            <p>üìå <strong>Key Notes:</strong></p>
            <ul>
                <li>Most <strong>concurrent queue implementations</strong> in Java <strong>do not allow nulls</strong> (they throw <code>NullPointerException</code> if you try to insert).</li>
                <li>Only <strong>LinkedList (when used as Queue/Deque)</strong> permits <strong>multiple null elements</strong>.</li>
            </ul>
        </details>
    </details>
    <details open>
        <summary><h2>üéØ Set Implementations</h2></summary>

        <details open>
            <summary><strong>üö´ Set Implementations</strong></summary>

            <h3>HashSet</h3>
            <ul>
                <li>Unordered, unique elements</li>
                <li>Backed by <code>HashMap</code></li>
                <li>Average time: O(1)</li>
            </ul>

            <h3>LinkedHashSet</h3>
            <ul>
                <li>Ordered by insertion</li>
                <li>Slightly more memory than <code>HashSet</code></li>
            </ul>

            <h3>TreeSet</h3>
            <ul>
                <li>Sorted order (natural or custom <code>Comparator</code>)</li>
                <li>Backed by <strong>Red-Black Tree</strong></li>
                <li>Time complexity: O(log n)</li>
            </ul>

            <table>
                <thead>
                <tr>
                    <th>Type</th>
                    <th>Order Maintained</th>
                    <th>Sorted</th>
                    <th>Allows Duplicates</th>
                    <th>Thread Safe</th>
                    <th>Nulls Allowed</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td><strong>HashSet</strong></td>
                    <td>‚ùå</td>
                    <td>‚ùå</td>
                    <td>‚ùå</td>
                    <td>‚ùå</td>
                    <td><strong>One null</strong></td>
                </tr>
                <tr>
                    <td><strong>LinkedHashSet</strong></td>
                    <td>‚úÖ</td>
                    <td>‚ùå</td>
                    <td>‚ùå</td>
                    <td>‚ùå</td>
                    <td><strong>One null</strong></td>
                </tr>
                <tr>
                    <td><strong>TreeSet</strong></td>
                    <td>‚úÖ (Sorted)</td>
                    <td>‚úÖ</td>
                    <td>‚ùå</td>
                    <td>‚ùå</td>
                    <td><strong>None</strong> (throws <code>NullPointerException</code> if null is added, since it uses <code>Comparable</code> or <code>Comparator</code>)</td>
                </tr>
                </tbody>
            </table>

        </details>
    </details>
    <details open>
        <summary><h2>üßÆ Map Implementations</h2></summary>

        <table>
            <thead>
            <tr>
                <th>Type</th>
                <th>Ordered?</th>
                <th>Thread Safe</th>
                <th>Notes</th>
                <th>Nulls Allowed</th>
            </tr>
            </thead>
            <tbody>
            <tr><td><strong>HashMap</strong></td><td>‚ùå</td><td>‚ùå</td><td>Most used, allows one null key</td><td><strong>1 null key, multiple null values</strong></td></tr>
            <tr><td><strong>LinkedHashMap</strong></td><td>‚úÖ</td><td>‚ùå</td><td>Preserves insertion order</td><td><strong>1 null key, multiple null values</strong></td></tr>
            <tr><td><strong>TreeMap</strong></td><td>‚úÖ (Sorted)</td><td>‚ùå</td><td>Sorted by natural/comparator key</td><td><strong>No null keys, multiple null values</strong> (unless comparator supports nulls explicitly)</td></tr>
            <tr><td><strong>Hashtable</strong></td><td>‚ùå</td><td>‚úÖ (legacy)</td><td>Slower, use only for legacy support</td><td><strong>No null keys, no null values</strong></td></tr>
            <tr><td><strong>ConcurrentHashMap</strong></td><td>‚ùå</td><td>‚úÖ (modern)</td><td>Thread-safe, no null keys allowed</td><td><strong>No null keys, no null values</strong></td></tr>
            </tbody>
        </table>

        <hr/>

        <h3>üîë Key Differences Between <code>HashMap</code> and <code>Hashtable</code></h3>

        <table>
            <thead>
            <tr>
                <th>Feature</th>
                <th><code>HashMap</code></th>
                <th><code>Hashtable</code></th>
            </tr>
            </thead>
            <tbody>
            <tr><td><strong>Thread-safety</strong></td><td>Not synchronized (not thread-safe). Must be synchronized externally if used in multithreaded code.</td><td>Synchronized (thread-safe for concurrent access).</td></tr>
            <tr><td><strong>Performance</strong></td><td>Faster, since no synchronization overhead.</td><td>Slower, due to synchronized methods.</td></tr>
            <tr><td><strong>Null Keys/Values</strong></td><td>Allows <strong>one null key</strong> and multiple <strong>null values</strong>.</td><td><strong>Does not allow</strong> null keys or null values.</td></tr>
            <tr><td><strong>Legacy vs Modern</strong></td><td>Introduced in <strong>Java 1.2</strong> as part of the Collections Framework.</td><td>Legacy class from <strong>Java 1.0</strong>, prior to Collections Framework.</td></tr>
            <tr><td><strong>Iteration</strong></td><td>Iterators are <strong>fail-fast</strong> (throw <code>ConcurrentModificationException</code> if modified while iterating).</td><td>Enumerators are <strong>not fail-fast</strong>.</td></tr>
            <tr><td><strong>Use in new code</strong></td><td>Recommended for most cases (unless thread-safety is needed).</td><td>Considered obsolete; replaced by <code>ConcurrentHashMap</code> for thread-safe alternatives.</td></tr>
            </tbody>
        </table>

        <hr/>

        <h3>‚úÖ When to Use</h3>
        <ul>
            <li><strong>Use <code>HashMap</code></strong> ‚Üí When you don‚Äôt need synchronization and want better performance.</li>
            <li><strong>Use <code>ConcurrentHashMap</code></strong> ‚Üí Instead of <code>Hashtable</code> if you need thread safety in modern Java.</li>
            <li><strong>Avoid <code>Hashtable</code></strong> ‚Üí Kept mostly for backward compatibility with older codebases.</li>
        </ul>

        <hr/>

        <h3>üìå Example</h3>

        <pre><code class="language-java">
import java.util.*;

public class MapExample {
    public static void main(String[] args) {
        // HashMap
        Map&lt;Integer, String&gt; hashMap = new HashMap&lt;&gt;();
        hashMap.put(1, "Apple");
        hashMap.put(2, "Banana");
        hashMap.put(null, "Cherry"); // null key allowed
        hashMap.put(3, null);        // null value allowed
        System.out.println("HashMap: " + hashMap);

        // Hashtable
        Map&lt;Integer, String&gt; hashtable = new Hashtable&lt;&gt;();
        hashtable.put(1, "Dog");
        hashtable.put(2, "Cat");
        // hashtable.put(null, "Fish"); // ‚ùå NullPointerException
        // hashtable.put(3, null);      // ‚ùå NullPointerException
        System.out.println("Hashtable: " + hashtable);
    }
}
</code></pre>

        <hr/>

        <h3>üß† Thread Safety Comparison</h3>

        <table>
            <thead>
            <tr>
                <th>Collection</th>
                <th>Thread Safe?</th>
                <th>Alternative</th>
            </tr>
            </thead>
            <tbody>
            <tr><td>ArrayList</td><td>‚ùå</td><td><code>CopyOnWriteArrayList</code></td></tr>
            <tr><td>HashMap</td><td>‚ùå</td><td><code>ConcurrentHashMap</code></td></tr>
            <tr><td>HashSet</td><td>‚ùå</td><td><code>Collections.synchronizedSet()</code></td></tr>
            <tr><td>TreeSet</td><td>‚ùå</td><td><code>ConcurrentSkipListSet</code> (via concurrent pkg)</td></tr>
            <tr><td>Stack</td><td>‚úÖ (legacy)</td><td>Prefer <code>ArrayDeque</code></td></tr>
            <tr><td>Vector</td><td>‚úÖ</td><td>Use cautiously (legacy)</td></tr>
            </tbody>
        </table>

        <hr/>

        <details>
            <summary><strong>üß† equals() vs == vs hashCode()</strong></summary>

            <img src="images/JavaBasic/equalsHashCode.png" alt="equalsHashCode"/>
            <img src="images/JavaBasic/equalsVsDoubleEqual.png" alt="equalsVsDoubleEqual"/>

            <ul>
                <li>When used as keys in <code>HashMap</code> or elements in <code>HashSet</code>, override both.</li>
                <li><strong>Contract:</strong></li>
                <ul>
                    <li>If <code>a.equals(b)</code> is true ‚Üí <code>a.hashCode() == b.hashCode()</code> must be true</li>
                    <li>But the reverse isn't mandatory.</li>
                </ul>
            </ul>

            <pre><code class="language-java">
String a = "hello";
String b = new String("hello");

System.out.println(a == b);        // false
System.out.println(a.equals(b));   // true
</code></pre>

            <h4>When to override <code>hashCode()</code> and <code>equals()</code></h4>

            <pre><code class="language-java">
class Person {
    private int id;
    private String name;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Person)) return false;
        Person person = (Person) o;
        return id == person.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}
</code></pre>

            <p>When used in hash-based collections:</p>
            <pre><code class="language-java">
Map&lt;Person, String&gt; map = new HashMap&lt;&gt;();
map.put(new Person(1, "Alice"), "Engineer");
map.put(new Person(1, "Alice"), "Manager"); // Without proper equals & hashCode, both entries may exist
</code></pre>

            <hr/>

            <p><strong>Interview takeaway:</strong></p>
            <ul>
                <li><code>hashCode()</code> ‚Üí which bucket</li>
                <li><code>equals()</code> ‚Üí is it the same object logically?</li>
                <li>Together they prevent duplicates and ensure correct behavior.</li>
            </ul>

        </details>

        <p><a href="https://youtu.be/7k0VYHuUF6g?si=7bOzb74JFvNW2yD8" target="_blank"><strong>INTERNAL WORKING OF HASHMAP (Video)</strong></a></p>

        <hr/>

        <h3>üîÅ What Is Treeify and Threshold?</h3>

        <table>
            <thead>
            <tr>
                <th>Concept</th>
                <th>Description</th>
            </tr>
            </thead>
            <tbody>
            <tr><td><strong>Threshold</strong></td><td>When the number of key-value pairs exceeds <code>capacity * loadFactor</code> (default <code>0.75</code>), the map resizes (doubles in size).</td></tr>
            <tr><td><strong>Treeify</strong></td><td>When many entries exist in a single bucket (‚â•8 entries) and total capacity ‚â•64, the bucket is converted from a linked list to a red-black tree. This improves lookup performance from <code>O(n)</code> to <code>O(log n)</code>.</td></tr>
            <tr><td><strong>Untreeify</strong></td><td>If the bucket size drops below 6 after deletions, the tree is converted back to a linked list.</td></tr>
            </tbody>
        </table>

        <pre>
+---------------------------+
|   Object to be inserted   |
+---------------------------+
          |
          v
  1. Compute hashCode()
          |
          v
  +-------------------+
  | Hash bucket index |
  +-------------------+
          |
          v
--------------------------------------
|         HashMap Table[] (Buckets)  |
--------------------------------------
  |        |        |        |
  v        v        v        v
Bucket0  Bucket1  Bucket2  Bucket3 ...
                   |
                   v
+-----------------------------------------+
|   Linked List of Nodes (same index)     |
+-----------------------------------------+
| Node1 (key1, value1) ->                 |
| Node2 (key2, value2) ->                 |
| Node3 (key3, value3) -> ...             |
+-----------------------------------------+
                   |
If entries in list >= 8 AND capacity >= 64
                   |
                   v
+-------------------------------------+
| Convert list to Red-Black Tree      |
| (Treeify: O(n) ‚Üí O(log n) access)   |
+-------------------------------------+
</pre>

        <hr/>

        <table>
            <thead>
            <tr>
                <th>Feature</th>
                <th>Condition (When It Happens)</th>
            </tr>
            </thead>
            <tbody>
            <tr><td><strong>Resize</strong></td><td>When number of entries > capacity * loadFactor</td></tr>
            <tr><td><strong>Treeify</strong></td><td>When a single bucket has ‚â• 8 nodes and total capacity ‚â• 64</td></tr>
            <tr><td><strong>Linked List</strong></td><td>Default structure for collisions</td></tr>
            <tr><td><strong>Untreeify</strong></td><td>When nodes in a tree < 6, convert back to list</td></tr>
            </tbody>
        </table>

        <hr/>

        <table>
            <thead>
            <tr><th>Key Concept</th><th>Default Value / Behavior</th></tr>
            </thead>
            <tbody>
            <tr><td>Initial Capacity</td><td>16 buckets</td></tr>
            <tr><td>Load Factor</td><td>0.75</td></tr>
            <tr><td>Resize Threshold</td><td>16 √ó 0.75 = 12 entries</td></tr>
            <tr><td>Treeify Threshold</td><td>8 entries in a single bucket</td></tr>
            <tr><td>Minimum Capacity to Treeify</td><td>64 buckets</td></tr>
            <tr><td>Untreeify Threshold</td><td><6 entries in a tree bucket</td></tr>
            </tbody>
        </table>

        <hr/>

        <ul>
            <li><strong>Resizing</strong> ensures the map doesn‚Äôt get too crowded ‚Üí keeps lookup fast</li>
            <li><strong>Treeify</strong> ensures performance doesn't degrade with many hash collisions</li>
            <li><strong>Linked list</strong> is used unless there‚Äôs a high number of collisions</li>
        </ul>

        <p><strong>‚úÖ Final Notes:</strong></p>
        <ul>
            <li>Java 8 introduced <strong>treeification</strong> for performance improvements</li>
            <li>You don‚Äôt see this as a user, but it silently keeps <code>HashMap</code> fast</li>
            <li>Good hash functions help avoid treeification altogether</li>
        </ul>

        <h2>üß† What Is ConcurrentHashMap?</h2>

        <p><code>ConcurrentHashMap</code> is a <strong>thread-safe</strong> version of <code>HashMap</code> in Java.</p>

        <h3>‚úÖ Why Use It?</h3>
        <p>Because <strong>regular <code>HashMap</code> is not thread-safe</strong>. In a multithreaded program:</p>

        <ul>
            <li>Two threads inserting data at the same time ‚Üí can corrupt the internal structure of <code>HashMap</code>.</li>
            <li>This could lead to <strong>infinite loops</strong>, data loss, or unpredictable results.</li>
        </ul>

        <p><code>ConcurrentHashMap</code> allows:</p>

        <ul>
            <li><strong>Multiple threads</strong> to <strong>read and write</strong> safely</li>
            <li>Without needing to <strong>synchronize the whole map</strong></li>
        </ul>

        <hr>

        <h3>üîç How It Differs from HashMap</h3>

        <table>
            <tr><th>Feature</th><th>HashMap</th><th>ConcurrentHashMap</th></tr>
            <tr><td>Thread-safe?</td><td>‚ùå No</td><td>‚úÖ Yes</td></tr>
            <tr><td>Allows null keys/values</td><td>‚úÖ Yes</td><td>‚ùå No (throws NPE)</td></tr>
            <tr><td>Synchronization</td><td>‚ùå None</td><td>‚úÖ Fine-grained (segments / nodes)</td></tr>
            <tr><td>Performance (multi-threaded)</td><td>‚ö†Ô∏è Poor</td><td>üöÄ Optimized</td></tr>
            <tr><td>Internal Structure</td><td>Buckets + Linked List / Tree</td><td>Similar, but with <strong>thread-safe access</strong></td></tr>
        </table>

        <hr>

        <details>
            <summary><strong>‚öôÔ∏è Internal Working (Java 8 and above)</strong></summary>
            <p>In <strong>Java 8+</strong>, <code>ConcurrentHashMap</code> uses a <strong>lock-free, non-blocking approach</strong> for most operations, with <strong>segment-like behavior</strong> for write safety.</p>

            <h4>üî© Core Concepts:</h4>
            <ul>
                <li><strong>Bucket Array</strong> (like <code>HashMap</code>): Holds data</li>
                <li><strong>Synchronized only parts</strong> of the array (not the whole map)</li>
                <li>Uses:
                    <ul>
                        <li><code>synchronized</code> blocks only when needed</li>
                        <li><strong>CAS (Compare-And-Swap)</strong> operations for atomic updates</li>
                        <li><strong>Concurrent reads</strong> without locking</li>
                        <li><strong>Lock striping</strong>: Only one bucket is locked, not the whole map</li>
                    </ul>
                </li>
            </ul>
        </details>

        <hr>

        <details>
            <summary><strong>üîÑ Insertion Flow (Put Operation)</strong></summary>

            <pre>
Thread 1 ‚Üí map.put("A", 100);
Thread 2 ‚Üí map.put("B", 200);

Each thread:
- Computes hash of key
- Finds the bucket index
- If no collision ‚Üí CAS (lock-free insert)
- If collision ‚Üí Synchronize only that bucket‚Äôs node
</pre>

            <pre>
+-------------------------------+
|        ConcurrentHashMap      |
+-------------------------------+
|  [0]  [1]  [2]  [3]  [4] ...  |
|  |     |     |     |          |
|  v     v     v     v          |
|Node  Node  null  Node         |
| A=100 B=200      C=300        |
| (locked by T1) (locked by T2) |
+-------------------------------+

Multiple threads:
- T1 inserts "A" ‚Üí locks bucket 0
- T2 inserts "B" ‚Üí locks bucket 1
‚Üí No interference!
</pre>
        </details>

        <hr>

        <details>
            <summary><strong>üß™ Read Operation (Get)</strong></summary>
            <ul>
                <li><strong>Fully non-blocking</strong></li>
                <li>Multiple threads can <strong>read without locks</strong></li>
                <li>Achieved using <code>volatile</code> and safe memory visibility guarantees</li>
            </ul>
        </details>

        <hr>

        <details>
            <summary><strong>üîê Treeification & Resizing</strong></summary>
            <ul>
                <li>Just like <code>HashMap</code>, if too many collisions in a bucket ‚Üí <strong>treeified</strong> to Red-Black Tree.</li>
                <li><strong>Resizing</strong> is done using thread-safe cooperative resizing:
                    <ul>
                        <li>Multiple threads help resize</li>
                        <li>Old buckets are gradually copied to new array</li>
                    </ul>
                </li>
            </ul>
        </details>

        <hr>

        <h3>üö® What It Doesn‚Äôt Do</h3>

        <ul>
            <li>Doesn‚Äôt support <code>null</code> keys or values:
                <pre><code>map.put(null, "test"); // Throws NullPointerException</code></pre></li>
            <li>Doesn‚Äôt allow locking the entire map directly (<code>Collections.synchronizedMap()</code> if you need coarse locking).</li>
        </ul>

        <hr>

        <h3>‚úÖ When to Use ConcurrentHashMap</h3>

        <table>
            <tr><th>Use Case</th><th>Recommendation</th></tr>
            <tr><td>Multi-threaded caching</td><td>‚úÖ Yes</td></tr>
            <tr><td>Shared state in web server</td><td>‚úÖ Yes</td></tr>
            <tr><td>Replace synchronizedMap()</td><td>‚úÖ Better</td></tr>
            <tr><td>Single-threaded or read-heavy access</td><td>‚ùå Overkill</td></tr>
        </table>

        <hr>

        <h3>üìå Summary</h3>

        <table>
            <tr><th>Feature</th><th>Details</th></tr>
            <tr><td>Thread-safe?</td><td>‚úÖ Yes (fine-grained locking)</td></tr>
            <tr><td>Read operations</td><td>Lock-free</td></tr>
            <tr><td>Write operations</td><td>Per-bucket locking + CAS</td></tr>
            <tr><td>Structure</td><td>Buckets + linked list / tree</td></tr>
            <tr><td>Null keys/values</td><td>‚ùå Not allowed</td></tr>
            <tr><td>Performance</td><td>üöÄ Highly optimized</td></tr>
        </table>
    </details>

    <details>
        <summary>üîÅ <strong>Collections.synchronizedMap() vs ConcurrentHashMap</strong></summary>

        <h3>1. Collections.synchronizedMap(Map&lt;K, V&gt;)</h3>

        <ul>
            <li>Wraps a regular map with synchronized methods.</li>
            <li>Synchronizes on the entire map for every operation.</li>
            <li>Slower under high concurrency due to full-map lock.</li>
            <li>Manual synchronization needed during iteration.</li>
        </ul>

        <pre><code class="language-java">
Map&lt;String, String&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());
synchronized (map) {
    for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {
        System.out.println(entry.getKey() + " -> " + entry.getValue());
    }
}
</code></pre>

        <hr>

        <h3>2. <a href="https://javahungry.blogspot.com/2015/02/how-concurrenthashmap-works-in-java-internal-implementation.html">ConcurrentHashMap&lt;K, V&gt;</a></h3>

        <ul>
            <li>Fine-grained locking or lock-free (Java 8+).</li>
            <li>Allows concurrent access without blocking readers.</li>
            <li>Weakly consistent iterator (no ConcurrentModificationException).</li>
            <li>Best for high-concurrency scenarios.</li>
        </ul>

        <pre><code class="language-java">
Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();
map.put("A", "Apple");
map.put("B", "Banana");

for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {
    System.out.println(entry.getKey() + " -> " + entry.getValue());
}
</code></pre>

        <hr>

        <h4>‚öñÔ∏è Key Differences</h4>

        <table>
            <thead>
            <tr>
                <th>Feature</th>
                <th><code>Collections.synchronizedMap()</code></th>
                <th><code>ConcurrentHashMap</code></th>
            </tr>
            </thead>
            <tbody>
            <tr><td>Locking Mechanism</td><td>Entire map</td><td>Fine-grained locking</td></tr>
            <tr><td>Concurrency</td><td>Low</td><td>High</td></tr>
            <tr><td>Read Operations</td><td>Blocking</td><td>Lock-free (Java 8+)</td></tr>
            <tr><td>Write Operations</td><td>Full lock</td><td>Partial locking</td></tr>
            <tr><td>Iteration Safety</td><td>Must synchronize manually</td><td>Weakly consistent</td></tr>
            <tr><td>Null Keys/Values</td><td>‚úÖ Yes</td><td>‚ùå No (NPE thrown)</td></tr>
            <tr><td>Performance</td><td>Lower under contention</td><td>High scalability</td></tr>
            </tbody>
        </table>

        <hr>

        <h3>üß≠ When to Use What?</h3>

        <ul>
            <li>‚úÖ Use <code>Collections.synchronizedMap()</code> when:
                <ul>
                    <li>Few concurrent threads</li>
                    <li>You need <code>null</code> keys/values</li>
                    <li>Simplicity is more important than performance</li>
                </ul>
            </li>

            <li>‚úÖ Use <code>ConcurrentHashMap</code> when:
                <ul>
                    <li>High concurrency & performance is required</li>
                    <li>Safe iteration without locking is needed</li>
                    <li><code>null</code> keys/values are not needed</li>
                </ul>
            </li>
        </ul>

        <hr>

        <h3>‚ùó Why ConcurrentHashMap Disallows Nulls?</h3>

        <ul>
            <li>Prevents ambiguity in <code>map.get(key)</code>:
                <ul><li><code>null</code> might mean missing key or <code>null</code> value.</li></ul>
            </li>
            <li>Avoids needing extra synchronization for <code>null</code> checks.</li>
            <li>Ensures safe concurrent computation.</li>
        </ul>

    </details>


</details>
</div>