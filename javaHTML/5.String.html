<div class="tree-container">

<h1>Strings in Java</h1>

<details>
    <summary><strong>String vs StringBuffer vs StringBuilder vs String Pool</strong></summary>

<table>
    <thead>
    <tr>
        <th>Feature</th>
        <th>String</th>
        <th>StringBuffer</th>
        <th>StringBuilder</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>Mutability</td>
        <td>Immutable</td>
        <td>Mutable</td>
        <td>Mutable</td>
    </tr>
    <tr>
        <td>Thread Safety</td>
        <td>Thread-safe by nature</td>
        <td>Thread-safe (synchronized)</td>
        <td>Not thread-safe</td>
    </tr>
    <tr>
        <td>Performance</td>
        <td>Slow for concatenation</td>
        <td>Slower due to synchronization</td>
        <td>Faster (recommended for single-thread)</td>
    </tr>
    <tr>
        <td>Introduced</td>
        <td>Java 1.0</td>
        <td>Java 1.0</td>
        <td>Java 1.5</td>
    </tr>
    <tr>
        <td>Use Case</td>
        <td>When immutability needed</td>
        <td>Multi-threaded environment string manipulation</td>
        <td>Single-threaded environment string manipulation</td>
    </tr>
    </tbody>
</table>

<ul>
    <li>Since <code>String</code> is immutable, every manipulation creates a new object, which may cause performance overhead and memory churn.</li>
    <li><code>StringBuffer</code> and <code>StringBuilder</code> are mutable and provide methods like <code>append()</code>, <code>insert()</code>, <code>delete()</code>, and <code>substring()</code> for efficient string manipulation.</li>
    <li>Internally, the <code>+</code> operator for string concatenation uses either <code>StringBuffer</code> or <code>StringBuilder</code>.</li>
</ul>

<hr>

<h3>String Pool</h3>

<ul>
    <li>A <strong>String Pool</strong> (or <strong>String Intern Pool</strong>) is a special memory area in the Java heap where JVM stores literal String values.</li>
    <li>When a String literal is created, JVM checks the pool first. If it exists, the reference is reused; else, a new String object is created in the pool.</li>
    <li>This saves memory and improves performance.</li>
</ul>

<pre><code class="language-java">String literal = "Sarath";           // Uses String Pool
String object = new String("Sarath"); // New object on heap, not in pool by default

// Comparisons:
literal == object;  // false (different references)
literal == "Sarath"; // true (both point to pool)
</code></pre>

<hr>

<h3>Memory Areas Related to Strings</h3>

<ul>
    <li><strong>Eden Space:</strong> Where new objects (including String objects) are allocated.</li>
    <li><strong>PermGen Space (Permanent Generation):</strong> Used in older Java versions to store class metadata and interned Strings.</li>
    <li><strong>MetaSpace:</strong> Replaced PermGen since Java 8 to store class metadata outside the heap.</li>
</ul>

    <details>
        <summary><strong>üß† Java Memory Areas Related to Strings</strong></summary>

        <h3>Memory Areas Related to Strings</h3>
        <p>Strings are stored differently depending on how they are created and the Java version.</p>

        <pre class="mermaid">
  flowchart TD

      Start["String Creation"]

      Start --> IsLiteral{"Is it a Literal?"}

      %% new String path
      IsLiteral -- No --> NewString["new String(&quot;Hello&quot;) <br/>(Heap Object)"]
      NewString --> Eden["Eden Space (Young Gen)<br/>(in Heap)"]

      %% String literal path
      IsLiteral -- Yes --> Literal["&quot;Hello&quot; (String Literal)<br/>Goes to String Pool"]
      Literal --> Interned["Interned in:<br/>- PermGen (Java ‚â§ 7)<br/>- Metaspace (Java 8+)"]
  </pre>

        <hr/>

        <h3>Memory Areas Explained</h3>
        <img src="images/JavaBasic/HeapPermgenSpace.png" alt="HeapPermgenSpace" style="max-width:100%; border-radius:8px;">

        <table>
            <thead>
            <tr>
                <th>Area</th>
                <th>Description</th>
                <th>Java Version</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><strong>Eden Space</strong></td>
                <td>New objects, including new Strings created with <code>new</code></td>
                <td>All versions</td>
            </tr>
            <tr>
                <td><strong>PermGen Space</strong></td>
                <td>Stores class metadata and interned strings</td>
                <td>Java 7 and below</td>
            </tr>
            <tr>
                <td><strong>MetaSpace</strong></td>
                <td>Replaces PermGen for class metadata and interned strings</td>
                <td>Java 8 and above</td>
            </tr>
            </tbody>
        </table>

        <hr/>

        <h3>Interning and String Pool</h3>
        <ul>
            <li><strong>String Pool</strong> stores literals and interned strings.</li>
            <li><code>String.intern()</code> adds strings explicitly to the pool.</li>
            <li>Pool was in <strong>PermGen (‚â§Java7)</strong>, moved to <strong>MetaSpace (Java8+)</strong>.</li>
        </ul>

        <hr/>

        <h3>Example</h3>
        <pre><code class="language-java">
String a = "Hello";              // Stored in String pool
String b = new String("Hello");  // New object in Eden Space (Heap)

System.out.println(a == b);          // false
System.out.println(a == b.intern()); // true
  </code></pre>

        <hr/>

        <h3>Summary Table</h3>
        <table>
            <thead>
            <tr>
                <th>Java Version</th>
                <th>Heap (Eden Space)</th>
                <th>PermGen / MetaSpace</th>
                <th>String Pool Location</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><strong>Java ‚â§ 7</strong></td>
                <td><code>new String()</code> objects</td>
                <td>PermGen</td>
                <td>PermGen</td>
            </tr>
            <tr>
                <td><strong>Java 8+</strong></td>
                <td><code>new String()</code> objects</td>
                <td>MetaSpace</td>
                <td>MetaSpace</td>
            </tr>
            </tbody>
        </table>
    </details>

    <hr/>

    <details>
        <summary><strong>üß† Java Memory Spaces (JVM Memory Structure)</strong></summary>
    <p>Java Virtual Machine (JVM) memory is split into several <strong>memory areas</strong>, each with a <strong>specific purpose</strong> for managing objects, threads, and class-level data.</p>

    <hr/>

    <h3>üîÅ Flow Diagram (Markdown Text Format)</h3>

    <pre class="mermaid">
flowchart TD

    App["Java Application"]
    App --> JVM["JVM Memory Structure"]

    JVM --> Heap["Heap"]
    JVM --> Stack["Stack (Thread-local)"]
    JVM --> Metaspace["Metaspace (Class info)"]

    %% Heap internals
    Heap --> YoungGen["Young Generation<br/>(Eden + 2 Survivor spaces)"]
    Heap --> OldGen["Old Generation<br/>(Tenured space)"]

    %% Stack internals
    Stack --> Primitives["Primitive Locals"]

    %% Metaspace internals
    Metaspace --> ClassNames["Class Names"]
    Metaspace --> Methods["Methods"]
    Metaspace --> ConstantPool["Constant Pool"]
</pre>


<!--    <!DOCTYPE html>-->
<!--    <html lang="en">-->
<!--    <head>-->
<!--        <meta charset="UTF-8">-->
<!--        <meta name="viewport" content="width=device-width, initial-scale=1.0">-->
<!--        <title>JVM Memory Areas Explained</title>-->

<!--        <style>-->
<!--            body {-->
<!--                background-color: #1e1e1e;-->
<!--                color: #ddd;-->
<!--                font-family: "Segoe UI", Roboto, sans-serif;-->
<!--                line-height: 1.6;-->
<!--                padding: 20px;-->
<!--            }-->

<!--            h2, h3, h4 {-->
<!--                color: #fff;-->
<!--            }-->

<!--            code {-->
<!--                background-color: #2b2b2b;-->
<!--                color: #f8f8f2;-->
<!--                padding: 2px 5px;-->
<!--                border-radius: 4px;-->
<!--                font-family: Consolas, monospace;-->
<!--            }-->

<!--            pre code {-->
<!--                display: block;-->
<!--                background-color: #2b2b2b;-->
<!--                padding: 12px;-->
<!--                border-radius: 6px;-->
<!--                overflow-x: auto;-->
<!--            }-->

<!--            hr {-->
<!--                border: 0;-->
<!--                border-top: 1px solid #444;-->
<!--                margin: 24px 0;-->
<!--            }-->

<!--            table {-->
<!--                border-collapse: collapse;-->
<!--                width: 100%;-->
<!--                margin: 16px 0;-->
<!--                font-size: 15px;-->
<!--            }-->

<!--            th, td {-->
<!--                border: 1px solid #555;-->
<!--                padding: 10px 12px;-->
<!--            }-->

<!--            th {-->
<!--                background-color: #333;-->
<!--                color: #fff;-->
<!--                text-align: left;-->
<!--            }-->

<!--            td {-->
<!--                background-color: #222;-->
<!--            }-->

<!--            ul {-->
<!--                margin: 8px 0 8px 20px;-->
<!--            }-->

<!--            em {-->
<!--                color: #b3e5fc;-->
<!--            }-->
<!--        </style>-->
<!--    </head>-->

<!--    <body>-->

    <h2>üß© JVM Memory Areas Explained</h2>

    <h3>1. <strong>Heap</strong></h3>
    <ul>
        <li><strong>Purpose:</strong> Stores all <strong>objects</strong>, <strong>class instances</strong>, <strong>arrays</strong></li>
        <li><strong>Managed by:</strong> Garbage Collector (GC)</li>
        <li><strong>Subdivided into:</strong>
            <ul>
                <li><strong>Young Generation</strong>
                    <ul>
                        <li><strong>Eden Space:</strong> New objects created here.</li>
                        <li><strong>Survivor Spaces (S0/S1):</strong> Surviving objects from minor GC.</li>
                    </ul>
                </li>
                <li><strong>Old Generation:</strong> Long-lived objects promoted here.</li>
            </ul>
        </li>
    </ul>

    <hr>

    <h3>2. <strong>Young Generation (YG)</strong></h3>
    <ul>
        <li>Optimized for fast allocation and collection (minor GC).</li>
        <li><strong>Eden Space:</strong>
            <ul>
                <li>Where all new objects are created.</li>
                <li>If not garbage collected, moved to Survivor.</li>
            </ul>
        </li>
        <li><strong>Survivor Space (S0 &amp; S1):</strong>
            <ul>
                <li>Objects that survive GC cycles.</li>
                <li>After a few cycles, moved to Old Gen.</li>
            </ul>
        </li>
    </ul>

    <hr>

    <h3>3. <strong>Old Generation (Tenured)</strong></h3>
    <ul>
        <li>Stores <strong>long-living objects</strong> (e.g., strings in use, singletons).</li>
        <li>Collected less frequently via <strong>major GC</strong> (slower than minor GC).</li>
    </ul>

    <hr>

    <h3>4. <strong>Stack</strong></h3>
    <ul>
        <li><strong>Thread-local memory</strong></li>
        <li>Stores:
            <ul>
                <li>Method calls (stack frames)</li>
                <li>Primitive local variables</li>
                <li>Object references (not actual objects)</li>
            </ul>
        </li>
        <li>Automatically <strong>pushed/popped</strong> during method calls</li>
        <li>Faster than heap memory</li>
        <li>Throws <code>StackOverflowError</code> if exceeded</li>
    </ul>

    <hr>

    <h3>5. <strong>Metaspace (Java 8+)</strong></h3>
    <ul>
        <li>Stores <strong>class metadata</strong></li>
        <li>Replaced <strong>PermGen</strong> from Java 8 onwards</li>
        <li>Grows dynamically (unlike PermGen which had fixed size)</li>
        <li>Contains:
            <ul>
                <li>Class names</li>
                <li>Method/field metadata</li>
                <li>Constant pool (for that class)</li>
            </ul>
        </li>
        <li><strong>Not part of the heap</strong> ‚Äî resides in <strong>native memory</strong></li>
    </ul>

    <hr>

    <h3>6. <strong>Program Counter (PC) Register</strong></h3>
    <ul>
        <li><strong>Thread-specific:</strong> Keeps track of current instruction address</li>
        <li>Helps resume execution in the correct place</li>
    </ul>

    <hr>

    <h3>7. <strong>Native Method Stack</strong></h3>
    <ul>
        <li>For executing <strong>native (non-Java)</strong> methods via JNI (Java Native Interface)</li>
    </ul>

    <hr>

    <h4>‚úÖ Summary Table</h4>

    <table>
        <thead>
        <tr>
            <th>Memory Area</th>
            <th>Purpose</th>
            <th>Collected by GC</th>
            <th>Thread Scoped</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>Heap (Eden + Old)</td>
            <td>Stores objects, arrays</td>
            <td>‚úÖ</td>
            <td>‚ùå</td>
        </tr>
        <tr>
            <td>Stack</td>
            <td>Stores local variables &amp; method calls</td>
            <td>‚ùå</td>
            <td>‚úÖ</td>
        </tr>
        <tr>
            <td>Metaspace</td>
            <td>Class metadata</td>
            <td>‚úÖ (limited)</td>
            <td>‚ùå</td>
        </tr>
        <tr>
            <td>PC Register</td>
            <td>Tracks next instruction</td>
            <td>‚ùå</td>
            <td>‚úÖ</td>
        </tr>
        <tr>
            <td>Native Stack</td>
            <td>Native method handling</td>
            <td>‚ùå</td>
            <td>‚úÖ</td>
        </tr>
        </tbody>
    </table>

    <h4>JVM Memory Areas Explained</h4>

    <table>
        <thead>
        <tr>
            <th>Memory Area</th>
            <th>Purpose</th>
            <th>Notes</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td><strong>Heap</strong></td>
            <td>Stores objects and arrays</td>
            <td>Managed by Garbage Collector</td>
        </tr>
        <tr>
            <td><strong>Young Generation</strong></td>
            <td>New objects allocated here</td>
            <td>Eden + Survivor spaces</td>
        </tr>
        <tr>
            <td><strong>Old Generation</strong></td>
            <td>Long-lived objects moved here</td>
            <td>Major GC occurs</td>
        </tr>
        <tr>
            <td><strong>Stack</strong></td>
            <td>Stores method calls, primitives, references</td>
            <td>Thread-local, fast access</td>
        </tr>
        <tr>
            <td><strong>Metaspace</strong></td>
            <td>Stores class metadata and interned strings</td>
            <td>Outside heap, Java 8+</td>
        </tr>
        <tr>
            <td><strong>PC Register</strong></td>
            <td>Tracks current instruction address</td>
            <td>Thread-local</td>
        </tr>
        <tr>
            <td><strong>Native Method Stack</strong></td>
            <td>For native method execution</td>
            <td>JNI calls</td>
        </tr>
        </tbody>
    </table>

    <!--    <style>-->
<!--        details {-->
<!--            background-color: #1e1e1e;-->
<!--            color: #ddd;-->
<!--            border: 1px solid #444;-->
<!--            border-radius: 8px;-->
<!--            padding: 12px;-->
<!--            margin-bottom: 16px;-->
<!--        }-->
<!--        code {-->
<!--            background-color: #2b2b2b;-->
<!--            color: #f8f8f2;-->
<!--            padding: 2px 5px;-->
<!--            border-radius: 4px;-->
<!--            font-family: Consolas, monospace;-->
<!--        }-->
<!--        pre code {-->
<!--            display: block;-->
<!--            padding: 12px;-->
<!--            background-color: #2b2b2b;-->
<!--            border-radius: 6px;-->
<!--            overflow-x: auto;-->
<!--        }-->
<!--        table {-->
<!--            border-collapse: collapse;-->
<!--            width: 100%;-->
<!--            margin: 10px 0;-->
<!--        }-->
<!--        th, td {-->
<!--            border: 1px solid #555;-->
<!--            padding: 8px;-->
<!--        }-->
<!--        th {-->
<!--            background-color: #333;-->
<!--            color: #fff;-->
<!--        }-->
<!--        td {-->
<!--            background-color: #222;-->
<!--        }-->
<!--        hr {-->
<!--            border: 0;-->
<!--            border-top: 1px solid #444;-->
<!--            margin: 16px 0;-->
<!--        }-->
<!--    </style>-->



<!--<style>-->
<!--    body {-->
<!--        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;-->
<!--        line-height: 1.6;-->
<!--        color: #e0e0e0;-->
<!--        background-color: #1e1e1e;-->
<!--        padding: 20px;-->
<!--    }-->
<!--    code {-->
<!--        background-color: #2d2d2d;-->
<!--        color: #c586c0;-->
<!--        padding: 2px 5px;-->
<!--        border-radius: 4px;-->
<!--        font-family: Consolas, monospace;-->
<!--    }-->
<!--    pre {-->
<!--        background-color: #252526;-->
<!--        padding: 10px;-->
<!--        border-radius: 6px;-->
<!--        overflow-x: auto;-->
<!--        border: 1px solid #3c3c3c;-->
<!--    }-->
<!--    table {-->
<!--        border-collapse: collapse;-->
<!--        width: 100%;-->
<!--        margin-top: 10px;-->
<!--    }-->
<!--    th, td {-->
<!--        border: 1px solid #3c3c3c;-->
<!--        padding: 8px;-->
<!--    }-->
<!--    th {-->
<!--        background-color: #2c2c2c;-->
<!--        color: #dcdcdc;-->
<!--    }-->
<!--    tr:nth-child(even) {-->
<!--        background-color: #242424;-->
<!--    }-->
<!--    hr {-->
<!--        margin: 30px 0;-->
<!--        border: 0;-->
<!--        border-top: 1px solid #444;-->
<!--    }-->
<!--    h1, h2, h3 {-->
<!--        color: #ffffff;-->
<!--    }-->
<!--</style>-->

    <h3>String Literal vs String Object</h3>

    <ul>
        <li><strong>String Literal:</strong> Stored in the String pool.</li>
        <li><strong>String Object:</strong> Created via <code>new</code> keyword, stored in heap, separate from the pool.</li>
        <li><code>.intern()</code> can be used to add a String object to the pool explicitly.</li>
    </ul>

    <hr>

    <h3>String Manipulation: <code>concat()</code> vs <code>+</code> Operator</h3>

    <ul>
        <li><code>concat()</code> only creates a new String object if the length of the string being concatenated is greater than zero.</li>
        <li>The <code>+</code> operator always creates a new String object regardless.</li>
    </ul>

    <pre><code class="language-java">
String str1 = "Rock";
String str2 = "Star";
String str3 = str1.concat(str2); // "RockStar"
</code></pre>

    <hr>

    <h3>Deep Copy vs Shallow Copy</h3>

    <ul>
        <li><strong>Shallow Copy:</strong> Copies only the reference of an object; both objects point to the same data.</li>
        <li><strong>Deep Copy:</strong> Copies the actual data and creates an independent clone.</li>
    </ul>

    <hr>

    <h3>Why is String Immutable in Java?</h3>

    <ul>
        <li>Multiple references can point to the same String in the String pool.</li>
        <li>If String were mutable, one reference changing the String would affect others unexpectedly.</li>
        <li>Immutability ensures thread safety, security, and consistency.</li>
        <li>Immutable Strings have stable hash codes, making them reliable as keys in hash-based collections.</li>
    </ul>

    <hr>

    <h3>Creating an Immutable Class in Java</h3>

    <ol>
        <li>Declare the class as <code>final</code> so it can't be extended.</li>
        <li>Declare all fields as <code>private</code> and <code>final</code>.</li>
        <li>Do not provide setter methods.</li>
        <li>Initialize all fields via constructor (defensive copies for mutable fields).</li>
        <li>Provide only getters.</li>
        <li>Ensure deep copy of mutable objects.</li>
    </ol>
    </details>
</details>
    <details>
        <summary><strong>Wrapper Classes and Autoboxing</strong></summary>

        <p>Java provides wrapper classes for primitives to allow objects to represent primitive types.</p>

        <table>
            <thead>
            <tr><th>Primitive Type</th><th>Wrapper Class</th></tr>
            </thead>
            <tbody>
            <tr><td>int</td><td>Integer</td></tr>
            <tr><td>long</td><td>Long</td></tr>
            <tr><td>short</td><td>Short</td></tr>
            <tr><td>byte</td><td>Byte</td></tr>
            <tr><td>char</td><td>Character</td></tr>
            <tr><td>float</td><td>Float</td></tr>
            <tr><td>double</td><td>Double</td></tr>
            <tr><td>boolean</td><td>Boolean</td></tr>
            </tbody>
        </table>

        <h3>Autoboxing</h3>
        <ul>
            <li>Automatic conversion of primitive types to their corresponding wrapper classes.</li>
        </ul>

        <h3>Example Custom Wrapper Class Demonstrating Autoboxing</h3>

        <pre><code class="language-java">
public class MyInteger {
    private int value;

    // Constructor
    public MyInteger(int value) {
        this.value = value;
    }

    // Getter
    public int getValue() {
        return value;
    }

    // Setter
    public void setValue(int value) {
        this.value = value;
    }

    // Method demonstrating autoboxing
    public void setIntegerValue(Integer integerValue) {
        this.value = integerValue;  // Autoboxing converts Integer to int automatically
    }

    public static void main(String[] args) {
        MyInteger myIntWrapper = new MyInteger(42);
        System.out.println("Wrapped Value: " + myIntWrapper.getValue());

        myIntWrapper.setValue(100);
        System.out.println("Modified Value: " + myIntWrapper.getValue());

        myIntWrapper.setIntegerValue(123); // Autoboxing occurs here
        System.out.println("Autoboxed Value: " + myIntWrapper.getValue());
    }
}
</code></pre>

    </details>
    <details>
        <summary><strong>StackOverflow - Due to Out of Memory</strong></summary>

        <ul>
            <li>Occurs when a program has too many nested method calls without returning ‚Äî leading to memory exhaustion in the call stack.</li>
            <li>Each method call consumes stack memory for local variables, return addresses, and parameters.</li>
            <li>Common cause: infinite recursion or deeply nested calls.</li>
        </ul>

        <pre><code class="language-java">
public class StackOverflowExample {
    public static void recursiveMethod() {
        // Infinite recursion causes StackOverflowError
        recursiveMethod();
    }

    public static void main(String[] args) {
        recursiveMethod();
    }
}
</code></pre>

        <h4>üß† Explanation:</h4>
        <ul>
            <li>Every recursive call adds a new frame to the call stack.</li>
            <li>Since there's no termination, stack memory fills up completely.</li>
            <li>JVM then throws <code>java.lang.StackOverflowError</code>.</li>
        </ul>

    </details>
</div>