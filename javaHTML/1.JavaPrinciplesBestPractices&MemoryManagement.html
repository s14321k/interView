<!--<meta charset="UTF-8">-->
<!--<meta name="viewport" content="width=device-width, initial-scale=1.0">-->
<!--<title>Java Principles, Best Practices & Memory Management</title>-->
<!--&lt;!&ndash; Step 1 & 2: Link to the external stylesheet from the embedded document &ndash;&gt;-->
<!--&lt;!&ndash; The path is relative to this file (javaHTML/1.JavaPrinciplesBestPractices&MemoryManagement.html) &ndash;&gt;-->
<!--<link rel="stylesheet" type="text/css" href="../css/style.css">-->

<!--<script src="js/scripts.js"></script>-->

<h1 id="java-principles-best-practices-memory-management">Java Principles, Best Practices & Memory Management</h1>

<div class="tree-container">
    <details>
        <summary><strong>Java Principles & Best Practices</strong></summary>

        <details>
            <summary><strong>1. Single Responsibility Principle (SRP)</strong></summary>
            A class should have <strong>only one reason to change</strong>.
            <br><br>
            <strong>Bad Example:</strong>
<pre><code>class User {
    void saveToDatabase() {}
    void printUserDetails() {}
}</code></pre>
            <strong>Good Example:</strong>
<pre><code>class User {}

class UserRepository {
    void save(User user) {}
}

class UserPrinter {
    void print(User user) {}
}</code></pre>
        </details>

        <hr>
        <details>
            <summary><strong>2. Open/Closed Principle (OCP)</strong></summary>
            Classes should be <strong>open for extension, but closed for modification</strong>.
            <br><br>
            <strong>Bad Example:</strong>
<pre><code>class Discount {
    double getDiscount(String type) {
        if (type.equals("STUDENT")) return 0.2;
        if (type.equals("SENIOR")) return 0.3;
        return 0;
    }
}</code></pre>
            <strong>Good Example (using polymorphism):</strong>
<pre><code>interface Discount {
    double getDiscount();
}

class StudentDiscount implements Discount {
    public double getDiscount() { return 0.2; }
}

class SeniorDiscount implements Discount {
    public double getDiscount() { return 0.3; }
}</code></pre>
        </details>

        <hr>
        <details>
            <summary><strong>3. Liskov Substitution Principle (LSP)</strong></summary>
            Subtypes must be <strong>replaceable</strong> with their base types without breaking the program.
            <br><br>
            <strong>Bad Example:</strong>
<pre><code>class Bird {
        void fly() {}
    }
    class Ostrich extends Bird {  // Ostrich can't fly
        void fly() { throw new UnsupportedOperationException(); }
}</code></pre>
            <strong>Good Example:</strong>
<pre><code>interface Bird {}
    interface Flyable extends Bird { void fly(); }

    class Sparrow implements Flyable {
        public void fly() { System.out.println("Flying"); }
    }

    class Ostrich implements Bird {}</code></pre>
        </details>

        <hr>
        <details>
            <summary><strong>4. Interface Segregation Principle (ISP)</strong></summary>
            Clients should not be forced to implement <strong>unnecessary methods</strong>.
            <br><br>
            <strong>Bad Example:</strong>
<pre><code>interface Worker {
    void work();
    void eat();
}

class Robot implements Worker {
    public void work() {}
    public void eat() {} // Not applicable
}</code></pre>
            <strong>Good Example:</strong>
<pre><code>interface Workable { void work(); }
    interface Eatable { void eat(); }

class Robot implements Workable {
    public void work() {}
}</code></pre>
        </details>

        <hr>
        <details>
            <summary><strong>5. Dependency Inversion Principle (DIP)</strong></summary>
            Depend on <strong>abstractions</strong>, not on concrete implementations.
            <br><br>
            <strong>Bad Example:</strong>
        <pre><code>class MySQLDatabase {
    void connect() {}
}

class App {
    MySQLDatabase db = new MySQLDatabase();
}</code></pre>
            <strong>Good Example:</strong>
        <pre><code>interface Database { void connect(); }

class MySQLDatabase implements Database {
    public void connect() {}
}

class App {
    private Database db;
    App(Database db) { this.db = db; }
}</code></pre>
        </details>

        <hr>
        <details>
            <summary><strong>6. DRY (Don’t Repeat Yourself)</strong></summary>
            Avoid duplicating logic. Extract common behavior into methods/classes.
            <br><br>
            <strong>Bad Example:</strong>
<pre><code>int areaSquare(int side) { return side * side; }
    int areaRectangle(int length, int width) { return length * width;
    }</code></pre>
            <strong>Good Example:</strong>
            <pre><code>class ShapeUtils {
        static int area(int a, int b) { return a * b; }
    }</code></pre>
        </details>

        <hr>
        <details>
            <summary><strong>7. KISS (Keep It Simple, Stupid)</strong></summary>
            Prefer <strong>simple and clear solutions</strong> over clever but complex ones.
            <br><br>
            <strong>Bad Example:</strong>
            <pre><code>int add(int a, int b) {
        return (a | b) + (a & b); // Bitwise trick
    }</code></pre>
            <strong>Good Example:</strong>
            <pre><code>int add(int a, int b) {
        return a + b;
    }</code></pre>
        </details>

        <hr>
        <details>
            <summary><strong>8. YAGNI (You Aren’t Gonna Need It)</strong></summary>
            Don't write code for future needs that may never come.
            <br><br>
            <strong>Bad Example:</strong>
            <pre><code>class Car {
        void fly() {}  // Not needed now
    }</code></pre>
            <strong>Good Example:</strong>
            <pre><code>class Car {
        void drive() {}
    }</code></pre>
        </details>

        <hr>
        <details>
            <summary><strong>9. Validate Before Use</strong></summary>
            Always <strong>validate inputs</strong> before using them to avoid crashes and bugs.
            <br><br>
            <strong>Bad Example:</strong>
            <pre><code>int divide(int a, int b) {
        return a / b;  // Risk of divide by zero
    }</code></pre>
            <strong>Good Example:</strong>
            <pre><code>int divide(int a, int b) {
        if (b == 0) throw new IllegalArgumentException("Divider cannot be zero");
        return a / b;
    }</code></pre>
        </details>

        <hr>
        <details>
            <summary><strong>10. Favor Composition Over Inheritance</strong></summary>
            Use <strong>composition</strong> instead of inheritance when possible.
            <br><br>
            <strong>Bad Example:</strong>
            <pre><code>class Engine {}
    class Car extends Engine {}  // Wrong: Car is not an Engine
    </code></pre>
            <strong>Good Example:</strong>
            <pre><code>class Engine {}
    class Car {
        private Engine engine;
        Car(Engine engine) { this.engine = engine; }
    }</code></pre>
        </details>

        <hr>
        <details>
            <summary><strong>11. Law of Demeter (LoD)</strong></summary>
            An object should only talk to its <strong>direct friends</strong>, not strangers.
            <br><br>
            <strong>Bad Example:</strong>
            <pre><code>order.getCustomer().getAddress().getCity();
    </code></pre>
            <strong>Good Example:</strong>
            <pre><code>class Order {
        Customer customer;
        String getCustomerCity() {
            return customer.getCity();
        }
    }
    order.getCustomerCity();
    </code></pre>
        </details>

        <hr>
        <details>
            <summary><strong>12. Fail Fast Principle</strong></summary>
            Detect and report errors <strong>early</strong>, instead of failing silently.

            <strong>Usage Example:</strong>
            <pre><code>if (list == null) throw new IllegalArgumentException("List cannot be null");
    </code></pre>
        </details>

        <hr>
    </details>

    <details>
        <summary><strong>Java Memory Management Principles</strong></summary>
        <details>
            <summary><strong>1. Avoid Creating Unnecessary Objects</strong></summary>
            Unnecessary objects increase memory usage and GC pressure.
            <br><br>
            <strong>Bad Example:</strong>
            <pre><code>String s1 = new String("Hello"); // Creates unnecessary object
    </code></pre>
            <br>
            <strong>Good Example:</strong>
            <pre><code>String s1 = "Hello"; // Uses string pool
    </code></pre>
        </details>

        <hr>
        <details>
            <summary><strong>2. Use Primitives Where Possible</strong></summary>
            Primitives are faster and use less memory than their wrapper classes.
            <br><br>
            <strong>Bad Example:</strong>
            <pre><code>Long sum = 0L; // Uses wrapper
    for (long i = 0; i < Integer.MAX_VALUE; i++) {
        sum += i;
    }
    </code></pre>
            <br>
            <strong>Good Example:</strong>
            <pre><code>long sum = 0L; // Uses primitive
    for (long i = 0; i < Integer.MAX_VALUE; i++) {
        sum += i;
    }
    </code></pre>
        </details>

        <hr>
        <details>
            <summary><strong>3. Release Resources with `finally` or `try-with-resources`</strong></summary>
            Ensure resources like streams and connections are always closed.
            <br><br>
            <strong>Bad Example:</strong>
            <pre><code>FileInputStream input = new FileInputStream("file.txt");
    // Code that might throw exception
    input.close(); // Might not be called
    </code></pre>
            <br>
            <strong>Good Example (try-with-resources):</strong>
            <pre><code>try (FileInputStream input = new FileInputStream("file.txt")) {
        // Code here
    } // Automatically closed
    </code></pre>
        </details>

        <hr>
        <details>
            <summary><strong>4. Use <code>StringBuilder</code> for String Concatenation in Loops</strong></summary>
            Avoid using <code>+</code> in loops, as it creates many intermediate <code>String</code> objects.
            <br><br>
            <strong>Bad Example:</strong>
            <pre><code>String result = "";
    for (String s : list) {
        result += s;
    }
    </code></pre>
            <br>
            <strong>Good Example:</strong>
            <pre><code>StringBuilder sb = new StringBuilder();
    for (String s : list) {
        sb.append(s);
    }
    String result = sb.toString();
                </code></pre>
        </details>

        <hr>
        <details>
            <summary><strong>5. Be Mindful of Static Fields</strong></summary>
            Static fields can cause memory leaks if they hold references to objects that are no longer needed.
            <br><br>
            <strong>Example:</strong>
            <pre><code>// This list will never be garbage collected unless cleared manually
                    public static List&lt;Object&gt; objectCache = new ArrayList&lt;&gt;();
                </code></pre>
        </details>

        <hr>
        <details>
            <summary><strong>6. Close Resources Properly</strong></summary>
            Unclosed resources (files, sockets, DB connections) leak memory.
            <br><br>
            <strong>Bad Example:</strong>
            <pre><code>FileInputStream fis = new FileInputStream("data.txt");
                </code></pre>
            <br>
            <strong>Good Example (try-with-resources):</strong>
            <pre><code>try (FileInputStream fis = new FileInputStream("data.txt")) {
            // use fis
        }
        </code></pre>
        </details>

        <hr>
        <details>
            <summary><strong>7. Use StringBuilder/StringBuffer for Concatenation in Loops</strong></summary>
            String concatenation in loops creates multiple intermediate objects.
            <br><br>
            <strong>Bad Example:</strong>
            <pre><code>String result = "";
    for (int i = 0; i < 100; i++) {
        result += i;
    }
    </code></pre>
            <br>
            <strong>Good Example:</strong>
            <pre><code>StringBuilder sb = new StringBuilder();
    for (int i = 0; i < 100; i++) {
        sb.append(i);
    }
    String result = sb.toString();
    </code></pre>
        </details>

        <hr>
        <details>
            <summary><strong>8. Avoid Memory Leaks with Collections</strong></summary>
            Collections can hold references long after they are needed.
            <br><br>
            <strong>Bad Example:</strong>
            <pre><code>List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
    while (true) {
        list.add(new byte[1024]); // OutOfMemoryError
    }
    </code></pre>
            <br>
            <strong>Good Example:</strong>
            <pre><code>list.clear(); // Release references when no longer needed
    </code></pre>
            Or use <code>WeakHashMap</code> when keys should be garbage collected.
        </details>

        <hr>
        <details>
            <summary><strong>9. Use Object Pooling Carefully</strong></summary>
            <ul>
                <li>For lightweight objects, let GC handle them.</li>
                <li>For expensive resources (DB connections, threads), use pooling (<code>ExecutorService</code>, connection pools).</li>
            </ul>
            <br>
            <strong>Usage Example:</strong>
            <pre><code>ExecutorService executor = Executors.newFixedThreadPool(5);
    </code></pre>
        </details>

        <hr>
        <details>
            <summary><strong>10. Monitor and Tune Garbage Collection</strong></summary>
            <ul>
                <li>Use JVM options to optimize GC (<code>-Xms</code>, <code>-Xmx</code>, <code>-XX:+UseG1GC</code>).</li>
                <li>Monitor memory with tools like <strong>VisualVM, JConsole, Flight Recorder</strong>.</li>
            </ul>
            <br>
            <strong>Usage:</strong>
            <pre><code>java -Xms512m -Xmx1024m -XX:+UseG1GC MyApp
    </code></pre>
        </details>

        <hr>
        <details>
            <summary><strong>11. Weak References for Caching</strong></summary>
            Use <code>WeakReference</code> or <code>WeakHashMap</code> for objects that can be garbage collected.
            <br><br>
            <strong>Usage Example:</strong>
            <pre><code>Map&lt;Object, String&gt; cache = new WeakHashMap&lt;&gt;();
    </code></pre>
        </details>

        <hr>
        <details>
            <summary><strong>12. Prefer Local Variables Over Instance Variables</strong></summary>
            Local variables are eligible for GC as soon as the method exits, while instance variables may remain longer.
            <br><br>
            <strong>Usage Example:</strong>
            <pre><code>public int compute() {
    int temp = 100;  // released quickly
    return temp * 2;
}
</code></pre>
        </details>
    </details>

</div>


